# 差异与对比分析

## 1. 需求 vs 实现

| 需求点 | 代码实现 | 状态 | 备注 |
| :--- | :--- | :--- | :--- |
| **多 CSV 输入** | 使用 `request.files.getlist` 并 `pd.concat` 合并 | ✅ 匹配 | 已修正支持多文件 |
| **CSV 预处理 (排序/排名)** | `sort_values` + `reset_index` 生成排名 | ✅ 匹配 | 逻辑一致 |
| **CSV 表头处理** | `header=1` 跳过第一行索引 | ✅ 匹配 | 针对提供的数据样本优化 |
| **警报条件 A (排名差)** | `abs(rank1 - rank2) <= 5` | ✅ 匹配 | |
| **警报条件 B (前25%且高充)** | `rank <= 0.25*N` & `money >= 5000` | ✅ 匹配 | |
| **警报条件 C (战力差)** | `abs(pow1 - pow2) <= 10亿` | ✅ 匹配 | |
| **二次警报 (关联服检测)** | 递归查 XLSX 找 P1/P2，查 DAU <= 5 | ✅ 匹配 | |
| **二次警报输出** | 将 P1/P2 追加到 CSV | ✅ 匹配 | 用户要求累加警报 |
| **交换区服 (定位)** | 遍历/Map 查找 XLSX 行 | ✅ 匹配 | |
| **交换区服 (交换逻辑)** | 互换位置，并重排 (小号在前) | ✅ 匹配 | **关键逻辑**：Sort Pair 确保 Target < Part |
| **交换区服 (标色)** | 黄色填充 (`FFFF00`) | ✅ 匹配 | |
| **输出文件** | Alert CSV, Result XLSX | ✅ 匹配 | |
| **额外输出** | Swapped Log CSV | ✅ 匹配 | 用户后期追加的需求 |

## 2. 潜在风险与边界情况

| 场景 | 潜在问题 | 代码处理方式 | 评价 |
| :--- | :--- | :--- | :--- |
| **ID 不存在** | 输入的 ID 在 CSV 中找不到 | 打印 WARNING 日志并跳过 | 合理，防止 Crash，但用户需关注日志 |
| **XLSX 不匹配** | “正常组”的 ID 在 XLSX 中找不到 | 打印 WARNING 日志，不执行交换，不计入 `actual_swapped_count` | 合理，之前 Log 为空即因此导致 |
| **同一行互换** | 输入的一对 ID 恰好在 XLSX 同一行 | 代码检测 `r1_idx != r2_idx`，相同则跳过 | 合理，无法在同一行内“交换” |
| **多次交换** | 同一个 ID 在多组输入中出现 | `server_row_map` 会在每次交换后更新 | ✅ 逻辑正确，支持连续交换 |
| **DAU 缺失** | CSV 中某行 DAU 为空 | `fillna(0)` 处理 | 安全 |

## 3. 结论
代码逻辑完整覆盖了用户的所有显式需求，包括复杂的条件判断、Excel 样式修改以及多文件处理。

**验证重点**：
用户在使用时，最可能遇到的问题依然是 **数据一致性** 问题（即输入的 ID 在 CSV 或 XLSX 中找不到）。代码已通过日志和 `swapped_log.csv` 提供了足够的调试信息来应对这种情况。
